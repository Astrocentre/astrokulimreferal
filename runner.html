<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Endless Runner - Pro</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
  html, body {
    margin: 0; padding: 0; overflow: hidden; height: 100%;
    background: linear-gradient(to top, #70c5ce, #ffffff);
    font-family: 'Orbitron', monospace, sans-serif;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
  }
  canvas {
    display: block;
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: linear-gradient(to top, #70c5ce, #ffffff);
  }
  #ui {
    position: fixed;
    top: 10px; left: 50%;
    transform: translateX(-50%);
    color: #007acc;
    font-size: 26px;
    font-weight: 700;
    text-shadow: 0 0 10px #00aaff;
    z-index: 10;
    user-select: none;
  }
  #startBtn, #restartBtn {
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    background: #007acc;
    border: none;
    padding: 16px 40px;
    font-size: 24px;
    font-weight: 700;
    color: white;
    border-radius: 12px;
    cursor: pointer;
    box-shadow: 0 5px 15px rgba(0,122,204,0.6);
    user-select: none;
    z-index: 20;
  }
  #startBtn {
    top: 45%;
  }
  #restartBtn {
    top: 55%;
    display: none;
  }
  #message {
    position: fixed;
    top: 35%;
    left: 50%;
    transform: translateX(-50%);
    color: #007acc;
    font-size: 32px;
    font-weight: 700;
    text-shadow: 0 0 12px #00aaff;
    user-select: none;
    display: none;
    z-index: 20;
  }
</style>
</head>
<body>

<canvas id="game"></canvas>
<div id="ui">Score: 0</div>
<button id="startBtn">Start Game</button>
<div id="message"></div>
<button id="restartBtn">Restart</button>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreUI = document.getElementById('ui');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const message = document.getElementById('message');

  let w, h;
  function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener('resize', resize);

  // Game constants
  const groundHeight = 100;
  const gravity = 1.2;
  const runnerWidth = 60;
  const runnerHeight = 90;

  // Game variables
  let gameState = 'start'; // 'start', 'playing', 'gameover'
  let score = 0;
  let speed = 8;
  let obstacleSpawnInterval = 1500; // ms
  let lastObstacleTime = 0;
  let obstacles = [];

  // Runner object
  const runner = {
    x: 80,
    y: 0,
    vy: 0,
    width: runnerWidth,
    height: runnerHeight,
    isOnGround: false,
    frame: 0,
    frameTick: 0,
    frames: 12,
    color: '#007acc',
    jumpPower: 20
  };

  // Background layers for parallax
  const bgLayers = [
    { speed: 1, color: '#a2d4f4', yOffset: 60, height: 60 },
    { speed: 3, color: '#6bb5e9', yOffset: 30, height: 30 },
    { speed: 5, color: '#3e8ce9', yOffset: 10, height: 10 }
  ];
  const bgPositions = bgLayers.map(() => 0);

  // Obstacle class
  class Obstacle {
    constructor() {
      this.width = 40 + Math.random() * 40;
      this.height = 40 + Math.random() * 60;
      this.x = w + this.width;
      this.y = h - groundHeight - this.height;
      this.speed = speed;
      this.color = '#a0522d';
    }
    update() {
      this.x -= this.speed;
    }
    draw() {
      ctx.fillStyle = this.color;
      ctx.fillRect(this.x, this.y, this.width, this.height);
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.fillRect(this.x + 5, this.y + this.height, this.width - 10, 8);
    }
  }

  function drawRunner() {
    ctx.fillStyle = runner.color;
    ctx.fillRect(runner.x, runner.y, runner.width, runner.height);

    // Simple legs animation
    ctx.fillStyle = '#005a9c';
    let legHeight = 20;
    let legWidth = 15;
    let legYOffset = runner.height - legHeight;

    if ((runner.frame % 12) < 6) {
      ctx.fillRect(runner.x + 10, runner.y + legYOffset, legWidth, legHeight);
      ctx.fillRect(runner.x + runner.width - 25, runner.y + legYOffset - 5, legWidth, legHeight);
    } else {
      ctx.fillRect(runner.x + 10, runner.y + legYOffset - 5, legWidth, legHeight);
      ctx.fillRect(runner.x + runner.width - 25, runner.y + legYOffset, legWidth, legHeight);
    }

    // Eye
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(runner.x + runner.width - 20, runner.y + 25, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(runner.x + runner.width - 22, runner.y + 25, 4, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawGround() {
    ctx.fillStyle = '#654321';
    ctx.fillRect(0, h - groundHeight, w, groundHeight);
  }

  function drawBackground() {
    bgLayers.forEach((layer, i) => {
      let x1 = bgPositions[i];
      let x2 = x1 + w;
      ctx.fillStyle = layer.color;
      ctx.fillRect(x1, h - groundHeight - layer.yOffset, w, layer.height);
      ctx.fillRect(x2, h - groundHeight - layer.yOffset, w, layer.height);
      bgPositions[i] -= layer.speed;
      if(bgPositions[i] <= -w) bgPositions[i] = 0;
    });
  }

  function isColliding(rect1, rect2) {
    return !(rect1.x > rect2.x + rect2.width ||
             rect1.x + rect1.width < rect2.x ||
             rect1.y > rect2.y + rect2.height ||
             rect1.y + rect1.height < rect2.y);
  }

  function update(deltaTime) {
    if(gameState !== 'playing') return;

    // Runner physics
    runner.vy += gravity;
    runner.y += runner.vy;

    if(runner.y + runner.height >= h - groundHeight) {
      runner.y = h - groundHeight - runner.height;
      runner.vy = 0;
      runner.isOnGround = true;
    } else {
      runner.isOnGround = false;
    }

    // Animate runner frames
    runner.frameTick += deltaTime;
    if(runner.frameTick > 100) {
      runner.frame = (runner.frame + 1) % 12;
      runner.frameTick = 0;
    }

    // Update obstacles
    obstacles.forEach(o => o.update());
    obstacles = obstacles.filter(o => o.x + o.width > 0);

    // Spawn obstacles
    if(Date.now() - lastObstacleTime > obstacleSpawnInterval) {
      obstacles.push(new Obstacle());
      lastObstacleTime = Date.now();

      // Increase difficulty gradually
      if(obstacleSpawnInterval > 700) obstacleSpawnInterval -= 20;
      if(speed < 18) speed += 0.1;
    }

    // Check collisions
    for(const o of obstacles) {
      if(isColliding(runner, o)) {
        gameState = 'gameover';
        restartBtn.style.display = 'block';
        message.style.display = 'block';
        message.textContent = 'Game Over! Tap Restart.';
        playHitSound();
        break;
      }
    }

    // Update score
    score += 0.05 * speed;
    scoreUI.textContent = 'Score: ' + Math.floor(score);
  }

  function draw() {
    ctx.clearRect(0, 0, w, h);
    drawBackground();
    drawGround();
    drawRunner();
    obstacles.forEach(o => o.draw());

    if(gameState === 'start') {
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#007acc';
      ctx.font = 'bold 50px Orbitron, monospace';
      ctx.textAlign = 'center';
      ctx.fillText('Tap to Start', w/2, h/2);
      ctx.font = '20px monospace';
      ctx.fillText('Tap / Click to Jump', w/2, h/2 + 40);
    }
  }

  let lastTime = 0;
  function loop(timestamp = 0) {
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;

    update(deltaTime);
    draw();

    if(gameState !== 'gameover') {
      requestAnimationFrame(loop);
    }
  }

  function jump() {
    if(gameState === 'start') {
      startGame();
      return;
    }
    if(gameState !== 'playing') return;
    if(runner.isOnGround) {
      runner.vy = -runner.jumpPower;
      playJumpSound();
    }
  }

  function startGame() {
    gameState = 'playing';
    score = 0;
    speed = 8;
    obstacleSpawnInterval = 1500;
    lastObstacleTime = 0;
    obstacles = [];
    runner.y = h - groundHeight - runner.height;
    runner.vy = 0;
    restartBtn.style.display = 'none';
    message.style.display = 'none';
    scoreUI.textContent = 'Score: 0';
    lastTime = 0;
    loop();
  }

  restartBtn.onclick = () => startGame();
  startBtn.onclick = () => {
    startBtn.style.display = 'none';
    jump();
  };

  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    jump();
  }, {passive: false});
  canvas.addEventListener('mousedown', e => {
    e.preventDefault();
    jump();
  });

  // Sound effects
  function createSound(freq, type = 'square', duration = 0.1) {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (!AudioContext) return;
    const ctx = new AudioContext();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    gain.gain.setValueAtTime(0.1, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
    osc.stop(ctx.currentTime + duration);
    osc.onended = () => ctx.close();
  }
  function playJumpSound() { createSound(600, 'square', 0.1); }
  function playHitSound() { createSound(200, 'sawtooth', 0.3); }

  // Initial runner position
  runner.y = h - groundHeight - runner.height;
  message.style.display = 'none';

  draw();  // Draw initial start screen

})();
</script>

</body>
</html>
