<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AI Enhanced Endless Runner</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #222;
    font-family: 'Segoe UI', sans-serif;
  }
  canvas {
    display: block;
    background: linear-gradient(to top, #87ceeb, #e0f7ff);
  }
  #ui {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    color: white;
    text-align: center;
  }
  #score {
    font-size: 24px;
    font-weight: bold;
    text-shadow: 0 0 6px black;
  }
  .btn {
    margin-top: 10px;
    padding: 10px 30px;
    font-size: 20px;
    background: #007acc;
    border: none;
    color: white;
    border-radius: 8px;
    cursor: pointer;
    display: none;
  }
</style>
</head>
<body>

<canvas id="game"></canvas>
<div id="ui">
  <div id="score">Score: 0</div>
  <button id="startBtn" class="btn">Start</button>
  <button id="restartBtn" class="btn">Restart</button>
</div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const startBtn = document.getElementById("startBtn");
  const restartBtn = document.getElementById("restartBtn");
  const scoreUI = document.getElementById("score");

  let width, height;
  function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resize);
  resize();

  let gravity = 0.7;
  let gameSpeed = 6;
  let score = 0;
  let gameStarted = false;
  let gameOver = false;
  const groundHeight = 100;

  const player = {
    x: 100,
    y: 0,
    width: 50,
    height: 50,
    dy: 0,
    jumpForce: 15,
    grounded: false,
    color: "#fdd835",
    draw() {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
      ctx.fill();
    },
    update() {
      this.dy += gravity;
      this.y += this.dy;
      if (this.y + this.height >= height - groundHeight) {
        this.y = height - groundHeight - this.height;
        this.dy = 0;
        this.grounded = true;
      } else {
        this.grounded = false;
      }
    }
  };

  let obstacles = [];

  function spawnObstacle() {
    const size = 30 + Math.random() * 40;
    obstacles.push({
      x: width,
      y: height - groundHeight - size,
      width: size,
      height: size,
      color: Math.random() > 0.5 ? "#ef5350" : "#ff9800"
    });
  }

  function drawBackground() {
    // Ground
    ctx.fillStyle = "#4e342e";
    ctx.fillRect(0, height - groundHeight, width, groundHeight);

    // Clouds
    ctx.fillStyle = "rgba(255,255,255,0.5)";
    for (let i = 0; i < 5; i++) {
      const cloudX = (score / 5 + i * 200) % width;
      ctx.beginPath();
      ctx.arc(cloudX, 100 + (i % 2) * 30, 40, 0, Math.PI * 2);
      ctx.arc(cloudX + 40, 100 + (i % 2) * 30, 35, 0, Math.PI * 2);
      ctx.arc(cloudX - 40, 100 + (i % 2) * 30, 35, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function updateGame() {
    player.update();
    gameSpeed += 0.002; // AI: Increase difficulty over time

    for (let ob of obstacles) {
      ob.x -= gameSpeed;
    }
    obstacles = obstacles.filter(ob => ob.x + ob.width > 0);

    for (let ob of obstacles) {
      if (
        player.x < ob.x + ob.width &&
        player.x + player.width > ob.x &&
        player.y < ob.y + ob.height &&
        player.y + player.height > ob.y
      ) {
        gameOver = true;
        endGame();
      }
    }

    score += 1;
    scoreUI.textContent = `Score: ${Math.floor(score / 10)}`;
  }

  function drawGame() {
    ctx.clearRect(0, 0, width, height);
    drawBackground();
    player.draw();
    for (let ob of obstacles) {
      ctx.fillStyle = ob.color;
      ctx.fillRect(ob.x, ob.y, ob.width, ob.height);
    }
  }

  function gameLoop() {
    if (!gameStarted || gameOver) return;
    updateGame();
    drawGame();
    requestAnimationFrame(gameLoop);
  }

  function startGame() {
    score = 0;
    gameSpeed = 6;
    gameStarted = true;
    gameOver = false;
    player.y = height - groundHeight - player.height;
    player.dy = 0;
    obstacles = [];

    startBtn.style.display = "none";
    restartBtn.style.display = "none";
    scoreUI.textContent = "Score: 0";

    gameLoop();
  }

  function endGame() {
    gameStarted = false;
    restartBtn.style.display = "inline-block";
  }

  function jump() {
    if (player.grounded && gameStarted) {
      player.dy = -player.jumpForce;
      player.grounded = false;
    }
  }

  startBtn.onclick = startGame;
  restartBtn.onclick = startGame;

  document.addEventListener("keydown", e => {
    if (e.code === "Space") jump();
  });
  canvas.addEventListener("mousedown", jump);
  canvas.addEventListener("touchstart", jump, { passive: false });

  setInterval(() => {
    if (gameStarted && !gameOver) spawnObstacle();
  }, 1300);

  // Initial UI
  startBtn.style.display = "inline-block";
})();
</script>

</body>
</html>
